# Binary Search Trees
**Supported dynamic- set operations**
- SEARCH
- MINIMUM
- PREDECESSOR
- SUCCESSOR
- INSERT
- DELETE

*Uses*
- dictionary
- priority queue

On average basic dynamic-set operations take 0(log n) time on average.
## What is a binary search tree?
We can represent a BST by as linked data structure in which each node is an *object*. 

The root node is the *only* node who has a parent that is NIL.

**Binary-search-tree-property**:
Let x be a node in a BST. If y is a node in the left subtree of x, then y.key is less than or equal to x.key. If y is a node in the right subtree of x, then y.key is greater than or equal to x.key.

**Inorder tree walk**: prints the key of the root of a subtree between printing te values in its left subtree and printing those in its right subtree.

```
INORDER-TREE-WALK
if x != NIL
    INORDER-TREE-WALK(x.left)
    print x.key
    INORDER-TREE-WALK(x.right)
```

**Preorder tree walk**: prints the root before the values in either subtree

**Postorder tree walk**: prints the root after the values in its subtrees.

Exercises:
1.1 - on paper
1.2: The min-heap property guarantees that a child is nt larger than the parent but doesn't distinguish similarly between left and right children. With that in mind it can't print out the keys of an n-node tree in a sorted order in 0(n) time because there is no guarantee which subtree contains the next smallest element. 
1.3:
```
INORDER-TREE-WALK(Tree)
    S = empty stack
    current = Tree.root
    count = 0
    while !count
        if current != NIL
        PUSH(S, current)
        current = current.left
    else
        if !S.EMPTY
            current = POP(S)
            print current
            current = current.right
        else
            count = 1
```
1.4:
```

PREORDER-TREE-WALK(Tree)
if tree != NIL
    print Tree.key
    PRERDER-TREE-WALK(tree.left)
    PREORDER-TREE-WALK(tree.right)

POSTORDER-TREE-WALK(Tree)
if tree != NIL
    POSTORDER-TREE-WALK(tree.left)
    POSTORDER-TREE-WALK(tree.right)
        print Tree.key

```

## Querying a binary search treeUM
**Additional Query support**
- MINIMUM
- MAXIMUM
- SUCCESSOR
- PREDECESSOR

```
TREE-SEARCH(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, k)
    else 
        return TREE-SEARCH(x.right, k)

ITERATIVE-TREE-SEARCH(x, k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else
            x = x.right
    return x

TREE-MINIMUM(x)
    while x.left != NIL
        x = x.left
    return x


TREE-MAXIMUM(x)
    while x.right != NIL
        x = x.right
    return x


TREE-SUCCESSOR(x)
    if x.right != NIL
        return TREE-MINIMUM(x.right)
    y = x.p
    while y != NIL and x == y.right
        x = y
        y = y.p
    return y
```
Exercises:
2.1: c and e are not possible
2.2 

```
TREE-MINIMUM(x)
    if x.left != NIL
        return TREE-MINIMUM(x.left)
    else 
        return x


TREE-MAXIMUM(x)
    if x.right != NIL
        TREE-MAXIMUM(x.right)
    else
        return x
```

2.3

```
TREE-PREDECESSOR(x)
    if x.left != NIL
        return Tree-Maximum(x.left)
    y = x.p
    while y != NIL and x == y.left
        x = y
        y = y.p
    return y
```
## Insertion and Deletion


 
