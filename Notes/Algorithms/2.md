# Getting Started

## Insertion Sort
**Sorting Problem**
**Input:** A sequence of n numbers (a1, a2, ..... an)
**Output:** A permutation (reordering) (a1, a2, .... an) of the input sequence such as a, <= a2 .... <= an.

**Insertion Sort**
```
for j = 2 to A.length
    key = A[j]
    //Insert A[j] into the sorted sequence A[1..j-1]
    i = j - 1
    while i > 0 and A[i] > key
        A[i + 1] = A[i]
        i = i - 1
    A[i + 1] = key
```

Numbers that we want to sort are *keys*.

Difference between pseudo-code vs "real" code is that we ignore syntax and use whatever is clear/concise to specify a given algorithm. Not actually concerned with software engineering.        

*In place* means that making changes within the provided structure rather than making a new structure. 

**Three outcomes that must be proven about a loop invariant:**
- *Initialization:* it is true prior to the first iteration of the loop
- *Maintenance:* It is true before an iteration of the loop, it remains true before the next iteration
- *Termination:* When the loop terminates, the invariant gives us a useful property that helps show that the algorithm is correct.

### Exercises
1.1: On paper

1.2:
```
for j = 2 to A.length
    key = A[j]
    i = j - 1
    while i > 0 and A[i] < key
        A[i + 1] = A[i]
        i = i - 1
    A[i + 1] = key
```

1.3:  
```
linear search(array, target)
    i = 0
    while i < array.length
        return i if array[i] == target
    end
    return NIL

```

1.4:
```
Input: 2 arrays
Output: 1 array containing the sum of the 2 integers
add(array A, array B)
    result = []
    i = 0
    while i < array A. length 
        result[i] = array A[i] + array B [i]
    end
    return result
end
```

## Analyzing Algorithms

## Designing Algorithms 