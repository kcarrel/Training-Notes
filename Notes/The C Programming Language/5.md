# Pointers and Arrays
**Pointer**: a variable that contains the address of a variable.
*Note:* The type void * (pointer to void) replaces char * as the proper type for a generic pointer.
## Pointers and Addresses
A typical computer has an array of consecutively numbered or addressed memory. These can be manipulated individually or as a group.
**Common:**
1 byte: a char
Pair of 1 byte cells: can be treated as a short integer
Four adjacent bytes: form a long integer

**The unary operator: & - The address of an object**
Ex:
p = &c;
explanation: p is assigned the address of c and p is said to "point to" c.

The & operator is only applied to objects in memory 
Applied to: variables and array elements. 
Can't: expressions, constants or *register* variables.


**The unary operator: * - The indirection/dereferencing operator**
Accesses the object the pointer points to. 

ex:
```
int x = 1, y = 2, z[10];
int *ip;            /* ip is a pointer to int */

ip = &x;           /* ip now points to x */
y = *ip;           /* y is now 1 */
*ip = 0;           /* x is now 0 */
ip = &z[0];        /* ip now points to z[0] */
```
int *ip ---> says that the expression *ip is an int

* and & bind more tightly than arithmetic operators. 
examples:
y = *ip + 10; means that it takes whatever ip points at, adds 1 and assigns the result to y
*but*
*ip += 1; means that it increments what ip points to

Pointers are variables and can be used without dereferencing.
ex:
if iq is pointing to int:
iq = ip;
copies the contents of ip into iq; making iq point to whatever ip pointed to. 

## Pointers and Function Arguments
There is no direct way for a called function to alter a variable in the calling function in C. You must use a pointer!
Ex:
```
void swap(int x, int y)
{
    int temp;
    temp = x;
    x = y;
    y = temp;
}
```
**Right:** swap(&a,&b);
**Wrong:** swap(a, b);

Pointer arguments enable a function to access/change objects in the function its being called in. 

## Pointers and Arrays
Any operation that can bve achieved by array subscripting can also be done with pointers.
*Note*: pointer version will be faster but can be harder to understand. 
If a is an array and pa points to [0] in the a array. You can access the rest of the array *(pa+1), *(pa+2)

Indexing and pointer arithmetic is very close. The value of a variable or expression of type array is the address of element zero of the array. Ex:
pa = &a[0]; means that pa and a have identical values. 


a[i] can also be written as *(a+i)

Tldr: An array-and-index expression is equivalent to one written as a pointer and offset. 

**Note**:
A pointer is a variable so pa=a and pa++ is legal. a=pa and a++ are NOT!

## Address Arithmetic

**Rudimentary routines** (calls to afree must be made in the opposite order to the calls made on alloc - Stack/ Last-in and first-out list.)
alloc(n) returns a pointer p to n consecutive character positions which can be used by the caller of alloc to store characters.
afree(p) releases the storage to be reused later. 

Pointers and integers are not interchangeable. 
Pointers can be compared: if p and q point to members of the same array then ==, !=...etc works. 

A pointer and an integer may be added or subtracted
ex: p + n; means that the address of the n-th object beyond the one p currently points to. 

All pointer manipulations automatically take into account the size fot eh object pointed to. 


**Valid Pointer Operations**
- assignment of pointers of the same type
- adding or subtracting a pointer and an integer
- subtracting or comparing to zero
*Anything else is illegal*


## Character Pointers and Functions

## Pointer Arrays; Pointers to Pointers

## Multi-dimensional Arrays

## Initialization of Pointer Arrays

## Pointers vs Multi-dimensional Arrays

## Command-line Arguments

## Pointers to Functions

## Complicated Declarations